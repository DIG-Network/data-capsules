/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

declare class Buffer {
  constructor(array: ArrayLike<number>)
  constructor(arrayBuffer: ArrayBuffer)
  constructor(buffer: Buffer)
  constructor(string: string, encoding?: string)
  static from(array: ArrayLike<number>): Buffer
  static from(arrayBuffer: ArrayBuffer, byteOffset?: number, length?: number): Buffer
  static from(buffer: Buffer): Buffer
  static from(string: string, encoding?: string): Buffer
  length: number
  toString(encoding?: string): string
}

/** Result of a proof of work computation */
export interface ProofOfWorkResult {
  /** The nonce that was found */
  nonce: bigint
  /** The resulting hash as hex string */
  hash: string
  /** Number of attempts made */
  attempts: bigint
  /** Time taken in milliseconds */
  time_ms: number
  /** The difficulty that was satisfied */
  difficulty: number
  /** The target that was used (as hex string) */
  target: string
}
/** Progress information for proof of work computation */
export interface ProofOfWorkProgress {
  /** Current number of attempts */
  attempts: bigint
  /** Current nonce being tested */
  nonce: bigint
  /** Time elapsed so far in milliseconds */
  elapsed_ms: number
  /** Estimated attempts per second */
  attempts_per_second: number
}
/** Result of waiting for proof of work completion */
export interface ProofOfWorkWaitResult {
  /** Error message if computation failed, undefined if successful */
  error?: string
  /** Proof of work result if computation succeeded, undefined if failed */
  result?: ProofOfWorkResult
}
/**
 * Computes proof of work asynchronously using Bitcoin's target-based system.
 * This function returns a handle for cancellation and unlimited attempts by default.
 *
 * @param {Buffer} entropy_seed - The entropy seed (plotId) to bind the work to
 * @param {number} difficulty - The difficulty level (Bitcoin-style, where 1.0 is easiest)
 * @param {number} max_attempts - Maximum number of attempts before giving up (default: unlimited)
 * @param {boolean} log_attempts - Whether to log each hash attempt (default: false)
 * @param {boolean} double_sha - Whether to use double SHA-256 like Bitcoin (default: true)
 * @returns {ProofOfWorkHandle} Handle for cancellation and progress tracking
 */
export declare function computeProofOfWorkAsync(entropySeed: Buffer, difficulty: number, maxAttempts?: number | undefined | null, logAttempts?: boolean | undefined | null, doubleSha?: boolean | undefined | null): ProofOfWorkHandle
/**
 * Verifies that a nonce produces a hash that meets the Bitcoin difficulty target.
 *
 * @param {Buffer} entropy_seed - The entropy seed that was used
 * @param {number} nonce - The nonce to verify
 * @param {number} difficulty - The required difficulty level (Bitcoin-style)
 * @param {boolean} double_sha - Whether to use double SHA-256 like Bitcoin (default: true)
 * @returns {boolean} True if the nonce is valid for the given difficulty
 */
export declare function verifyProofOfWork(entropySeed: Buffer, nonce: number, difficulty: number, doubleSha?: boolean | undefined | null): boolean
/**
 * Convert a Bitcoin-style difficulty to the corresponding target value.
 *
 * @param {number} difficulty - The difficulty level (Bitcoin-style)
 * @returns {string} The target as a hex string
 */
export declare function difficultyToTargetHex(difficulty: number): string
/**
 * Calculate the difficulty that a given hash would satisfy.
 *
 * @param {Buffer} hash - The hash to analyze
 * @returns {number} The difficulty level this hash would satisfy
 */
export declare function hashToDifficulty(hash: Buffer): number
/**
 * Get the current difficulty algorithm version.
 * This version number is part of the network consensus.
 *
 * @returns {number} The algorithm version number
 */
export declare function getAlgorithmVersion(): number
/**
 * Get the algorithm specification hash.
 * This hash identifies the exact algorithm implementation.
 *
 * @returns {string} The algorithm specification identifier
 */
export declare function getAlgorithmSpec(): string
/**
 * CONSENSUS CRITICAL: Standardized verification with algorithm validation.
 * This function verifies both the proof of work AND the algorithm compatibility.
 *
 * @param {Buffer} entropy_seed - The entropy seed that was used
 * @param {number} nonce - The nonce to verify
 * @param {number} difficulty - The required difficulty level
 * @param {number} expected_version - Expected algorithm version (default: current)
 * @param {boolean} double_sha - Whether to use double SHA-256 (default: true)
 * @returns {boolean} True if the nonce is valid AND algorithm is correct
 */
export declare function verifyProofOfWorkStandardized(entropySeed: Buffer, nonce: number, difficulty: number, expectedVersion?: number | undefined | null, doubleSha?: boolean | undefined | null): boolean
/**
 * Get the standardized difficulty algorithm parameters.
 * These parameters are part of the network consensus.
 *
 * @returns {object} Algorithm parameters
 */
export declare function getAlgorithmParameters(): AlgorithmParameters
/** Algorithm parameters object */
export interface AlgorithmParameters {
  /** Algorithm version number */
  version: number
  /** Algorithm specification hash */
  specHash: string
  /** Base number of zero bits for difficulty 1.0 */
  baseZeroBits: number
  /** Logarithmic multiplier for difficulty scaling */
  logMultiplier: number
  /** Maximum allowed zero bits */
  maxZeroBits: number
}
/** Handle for cancelling a proof of work computation */
export declare class ProofOfWorkHandle {
  /** Cancel the proof of work computation */
  cancel(): void
  /** Check if the computation has been cancelled */
  isCancelled(): boolean
  /** Get the current number of attempts (approximate) */
  getAttempts(): bigint
  /** Check if the computation has completed (found solution) */
  isCompleted(): boolean
  /** Check if there was an error (cancelled or max attempts reached) */
  hasError(): boolean
  /** Get the error message if there was an error */
  getError(): string | null
  /** Get the result if the computation completed successfully */
  getResult(): ProofOfWorkResult | null
  /** Get progress information */
  getProgress(): ProofOfWorkProgress
  /** Get the difficulty level for this computation */
  getDifficulty(): number
  /** Wait for the proof of work computation to complete and return [error, result] */
  waitForComplete(): Promise<ProofOfWorkWaitResult>
}
